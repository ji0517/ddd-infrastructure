# <div align='center' >DDD中事件总线的应用</div>
# 1. DDD与领域事件
随着微服务架构的不断流行，很多企业开始在自己的业务中落地微服务。他们觉得采用微服务架构会让系统的开发与运维管理变得简单高效，并且还能提高系统的可用性。  

但是当他们实际执行的时候，才发现就算采用了微服务架构也不能解决他们的问题，反而带来很多开发与运维上的负担。 


于是他们就试着去找解决方案，最后很多人发现其实是自己划分微服务的方法错了，他们应该用 DDD（领域驱动设计） 的思想去指导微服务的实践。  


那什么是 DDD 呢？用一句话来说，DDD 是一种在面向高度复杂的软件系统时，关于如何去建模的方法论，它的关键点是根据系统的复杂程度建立合适的模型。  

DDD 的一个生命周期是这样的：在设计和实现一个系统的时候，召集这个系统的领域专家和开发人员，通常通过Event Storming（事件风暴）的方式（实现方式有多种，目前一般采用），共同完成该领域模型的构建，在这个过程中，业务架构和系统架构等问题都得到了解决，之后将领域模型中关于系统架构的主体映射为实现代码（其中限界上下文和聚合映射成微服务。实体、值对象、领域服务、领域事件、仓储等映射成各层代码。），完成系统的实现落地。   

通过上面我们看到领域事件（Domain Events）是领域驱动设计（Domain Driven Design，DDD）中的一个概念，用于捕获我们所建模的领域中所发生过的事情。举个例子比如设计一个电商系统的时候，我们下了一个订单，这时就会产生一个领域事件。所有感兴趣的微服务都可以订阅这个事件，比如积分系统、消息通知系统、库存系统都可以根据这个事件触发相应的操作。  

# 2. 事件总线介绍
## 事件总线的大体流程
* 发出事件通知的一方称为发送者 (Publisher) ,关心事件的一方称为订阅者 (Subscriber)。  
* 关心一件事，便会收集这件事情相关的信息。而这些都将会转换为消息流，在订阅这件事情的领域间传播，一旦命中所要关心的事情，就由订阅者自行去处理接下来的事情。  
![事件总线](http://221.130.48.66:30013/jason/ddd-infrastructure/-/raw/master/doc/eventbus/img/eventbus.png)  

以上eventbus示意图大致流程是这样的：
* 服务接口触发事件
* eventbus 分发事件，如果存在领域内订阅者，直接分发到指定订阅者，再将事件消息存库定时发送至队列
* 如果不存在领域内订阅者，事件消息直接存库并定时发送队列
* 消息在发送成功以后会被清除，为了保证事务的一致性。建议事件db共享业务数据源
* 订阅者只需要订阅事件双方规约好的topic和事件类型就可以命中需要的事件消息

## 为什么要引入事件
### 优雅的解决问题
* 当遇到某个状态，需要第三方系统作出应对，开发者可能不是那么愿意为此去加入冗长的代码甚至引入别人的 api ，而这与当前领域相关性也不会太大。领域事件帮助开发者更加优雅的解决了这个问题  

### 降低耦合，高拓展性
* 事件对于触发的一方来说只是一个函数，而不再是一大堆的业务逻辑，将这些与领域解藕，让业务系统只关心业务！
* 如果发送方需要发送更多的事件，只需要触发更多的方法即可；对于订阅者来说，可以订阅任何领域发过来的事件消息

### 高复用性
* 事件可能只需要做一次，而发送者与订阅者是 1:N 的，一个事件可以被不同的接口多次触发。

### 最终一致性与弱关联
* 通常需要保证数据的最终一致性，这对于事件消息来说还是很容易的，这得益于基于消息的重试机制。与主业务关系不大的业务，如：发邮件，发短信等,这种弱关联是可以在事件中获益！

### 提升性能
* 原来多个微服务中的调用是需要排队调用的，现在可以并发执行  

# 3. 实践事件总线
## 举一个电商系统的例子
我们知道在DDD中，为了方便讨论和事件风暴，会先把系统分为一个个域进行讨论，电商系统核心域大至可以分为：商品、销售、物流、订单、支付、库存这几个域。通用域有：消息通知，评论等。
由于篇幅，我们这里对核心域中的订单和库存进行一个分析和拆分微服务。  
## DDD的分析和结果
* 领域建模：通过事件风暴中的分析，我们得到了
  ![DDD分析](http://221.130.48.66:30013/jason/ddd-infrastructure/-/raw/master/doc/eventbus/img/ddd_a.png)   
  通过上图可以看出，订单创建成功后我们触发了一个领域事件，所有对些事件感兴趣的微服务都可以订阅这个事件，我们将订单和库存分成二个聚合。为了例子子简单，目前将这2个聚合放在一个限界上下文中   
* 映射成微服务的代码模型
  ![DDD设计](http://221.130.48.66:30013/jason/ddd-infrastructure/-/raw/master/doc/eventbus/img/ddd_c.png)   
  我们看到在库存应用层有StockListener监听订单创建事件。收到此事件后库存微服务修改库存。 业务比较简单，这里就省略对象模型的建模，具体有什么字段，可以查看代码   
## 领域事件面临的问题和解决方法  
因为领域事件的实现方式是由消息队列来实现的，所以面临的问题和消息对列消费的问题是一样的。   

* 消息重复消费的问题
  试想一下，如果订单发了一次消息后，库存减了2次是什么情况？那是什么情况造成重复消费的呢？当库存消费了这条消息，这条消息应该删除的，但是这时候应用挂了，重启后发现消息还在就再消费了一遍。这个情况比较好解决，每次消费的时候需要先判断消息有没有被消费过就行了。
* 消息投递成功但网络闪断或者应用挂掉的问题
  这类情况会产生的问题是我消息发送成功了，但是由于应用挂掉导致我没有收到回执，又会重复发信息。这里就需要一种机制要本地事务执行成功后消息一定要投递成功。事务消息就是用来解决这个问题的。下图所示：   
  ![事务消息](http://221.130.48.66:30013/jason/ddd-infrastructure/-/raw/master/doc/eventbus/img/ddd_trans.png)   
  1、Producer向 MQ 服务端发送消息。  
  2、MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。  
  3、Producer中executeLocalTransaction()方法开始执行本地事务逻辑。  
  4、Producer根据本地事务执行结果向 MQ Server 提交二次确认（Commit 或是 Rollback），MQ Server 收到 Commit 状态则将半消息标记为可投递，Consumer最终将收到该消息；MQ Server 收到 Rollback 状态则删除半消息，Consumer将不会接受该消息。
  在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达 MQ Server，经过固定时间60s后 MQ Server 将对该消息发起消息回查。  
  5、Producer收到消息回查后，需要检查对应消息的本地事务执行的最终结果。  
  6、Producer根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍按照步骤4对半消息进行操作。  

  事务消息发送对应步骤1、2、3、4，事务消息回查对应步骤5、6、7。


  为了本地事件和远程事件的方便使用，我们已经把他集成到event-bus中了，并且统一了调用方法和消费方式。
  
## 查看结果